# INTRO

[[exercises]]
name = "intro1"
path = "exercises/intro/intro1.rs"
mode = "compile"
hint = """
Supprimez le commentaire I AM NOT DONE dans le fichier exercises/intro/intro1.rs
pour passer à l'exercice suivant."""

[[exercises]]
name = "intro2"
path = "exercises/intro/intro2.rs"
mode = "compile"
hint = """
Ajoutez un argument après la chaîne de format."""

# VARIABLES

[[exercises]]
name = "variables1"
path = "exercises/variables/variables1.rs"
mode = "compile"
hint = """
Il manque à la déclaration de la ligne 8 un mot-clé qui est nécessaire en Rust
pour créer une nouvelle liaison de variable."""

[[exercises]]
name = "variables2"
path = "exercises/variables/variables2.rs"
mode = "compile"
hint = """
Le message du compilateur dit que Rust ne peut pas déduire le type de la variable `x` avec ce qui est donné ici.
variable `x` avec ce qui est donné ici.
Que se passe-t-il si vous annotez la ligne 7 avec une annotation de type ?
Que se passe-t-il si vous donnez une valeur à x ?
Et si vous faites les deux ?
Quel type devrait être x ?
Que se passe-t-il si x est du même type que 10 ? Et s'il est d'un type différent?"""

[[exercises]]
name = "variables3"
path = "exercises/variables/variables3.rs"
mode = "compile"
hint = """
Oups ! Dans cet exercice, nous avons une variable binding que nous avons créée à la ligne 7, et nous essayons de l'utiliser à la ligne 8, mais nous ne lui avons pas donné de nom.
ligne 7, et nous essayons de l'utiliser à la ligne 8, mais nous ne lui avons pas donné de valeur.
valeur. Nous ne pouvons pas imprimer quelque chose qui n'existe pas ; essayez de donner une valeur à x !
C'est une erreur qui peut causer des bogues et qui est très facile à commettre dans n'importe quel langage de programmation.
-- heureusement, le compilateur Rust l'a détectée pour nous !"""

[[exercises]]
name = "variables4"
path = "exercises/variables/variables4.rs"
mode = "compile"
hint = """
En Rust, les variables sont immuables par défaut. Mais ici, nous essayons
de réassigner une valeur différente à x ! Il y a un mot-clé que nous pouvons utiliser pour rendre
une liaison de variable mutable."""

[[exercises]]
name = "variables5"
path = "exercises/variables/variables5.rs"
mode = "compile"
hint = """
Dans variables4, nous avons déjà appris à rendre une variable immutable mutable à l'aide d'un mot-clé spécial.
Malheureusement, cela ne nous aide pas beaucoup dans cet exercice
car nous voulons assigner une valeur de type différent à une variable existante. Parfois
on peut également réutiliser des noms de variables existants parce qu'on ne fait que convertir des
dans des types différents, comme dans cet exercice.
Heureusement, Rust dispose d'une solution puissante à ce problème : le " Shadowing " !
Vous pouvez en savoir plus sur le "Shadowing" dans la section "Variables et mutabilité" du livre :
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing
Essayez de résoudre cet exercice après avoir utilisé cette technique."""

[[exercises]]
name = "variables6"
path = "exercises/variables/variables6.rs"
mode = "compile"
hint = """
Nous connaissons les variables et la mutabilité, mais il existe un autre
type de variable : les constantes.
Les constantes sont toujours immutables et sont déclarées avec le mot-clé "const"
plutôt qu'avec le mot-clé "let".
Les types des constantes doivent également toujours être annotés.

Pour en savoir plus sur les constantes et les différences entre les variables et les constantes, consultez la rubrique "Constantes" dans la section "Variables et mutabilité" du livre :
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants
"""

# FUNCTIONS

[[exercises]]
name = "functions1"
path = "exercises/functions/functions1.rs"
mode = "compile"
hint = """
Cette fonction `main` appelle une fonction dont elle s'attend à ce qu'elle existe, 
mais cette fonction n'existe pas.
Elle s'attend à ce que cette fonction porte le nom `call_me`.
Elle s'attend à ce que cette fonction ne prenne aucun argument et ne retourne 
aucune valeur.
Cela ressemble beaucoup à `main`, n'est-ce pas ?"""

[[exercises]]
name = "functions2"
path = "exercises/functions/functions2.rs"
mode = "compile"
hint = """
Rust exige que toutes les parties de la signature d'une fonction aient des 
annotations de type, mais il manque l'annotation de type `num` à `call_me`."""

[[exercises]]
name = "functions3"
path = "exercises/functions/functions3.rs"
mode = "compile"
hint = """
Cette fois, la *déclaration* de la fonction est correcte, mais il y a 
quelque chose qui ne va pas à l'endroit où lors de l'appel de la fonction.
Pour rappel, vous pouvez librement jouer avec différentes solutions 
dans Rustlings! Le mode veille ne passera à l'exercice suivant que
si vous supprimez le commentaire I AM NOT DONE."""

[[exercises]]
name = "functions4"
path = "exercises/functions/functions4.rs"
mode = "compile"
hint = """
Le message d'erreur pointe vers la ligne 17 et indique qu'il attend un type 
après le `->`. C'est là que le type de retour de la fonction devrait être 
-- regardez la fonction `is_even` pour un exemple !

De plus, vous avez compris que, techniquement, `u32` serait le type le 
plus approprié pour les prix, puisqu'ils ne peuvent pas être négatifs ?
Si c'est le cas, bravo !"""

[[exercises]]
name = "functions5"
path = "exercises/functions/functions5.rs"
mode = "compile"
hint = """
Il s'agit d'une erreur très courante qui peut être corrigée en supprimant
un caractère. Elle se produit parce que Rust fait la distinction entre les 
expressions et les instructions : les expressions retournent une valeur 
basée sur leur(s) opérande(s), et les instructions retournent simplement 
un type () qui se comporte exactement comme `void` dans le langage C/C++.

Nous voulons retourner une valeur de type `i32` à partir de la fonction 
`square`, mais elle retourne un type `()`...
Ce n'est pas la même chose. Il y a deux solutions :
1. Ajouter un `return` avant `num * num;`
2. Supprimer `;`, et faire en sorte que ce soit `num * num`"""

# IF

[[exercises]]
name = "if1"
path = "exercises/if/if1.rs"
mode = "test"
hint = """
Il est possible de le faire en une seule ligne si vous le souhaitez !
Quelques exemples similaires dans d'autres langages :
- En C(++) ce serait : `a > b ? a : b`
- En Python, ce serait : `a if a > b ? a : b` :  `a if a > b else b`
Rappelez-vous qu'en Rust :
- la condition `if` n'a pas besoin d'être entourée de parenthèses
- Les `if`/`else` sont des expressions conditionnelles
- Chaque condition est suivie d'un bloc `{}`."""

[[exercises]]
name = "if2"
path = "exercises/if/if2.rs"
mode = "test"
hint = """
Pour cette première erreur du compilateur, il est important en Rust que 
chaque bloc conditionnel renvoie le même type !
Pour que les tests passent, vous aurez besoin de quelques
conditions vérifiant différentes valeurs d'entrée."""

[[exercises]]
name = "if3"
path = "exercises/if/if3.rs"
mode = "test"
hint = """
En Rust, chaque branche d'une expression `if` doit retourner le même type 
de valeur. Assurez-vous que le type est cohérent entre tous les bras."""

# QUIZ 1

[[exercises]]
name = "quiz1"
path = "exercises/quiz1.rs"
mode = "test"
hint = "Pas d'indice cette fois ;)"

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
path = "exercises/primitive_types/primitive_types1.rs"
mode = "compile"
hint = "Pas d'indice cette fois ;)"

[[exercises]]
name = "primitive_types2"
path = "exercises/primitive_types/primitive_types2.rs"
mode = "compile"
hint = "Pas d'indice cette fois ;)"

[[exercises]]
name = "primitive_types3"
path = "exercises/primitive_types/primitive_types3.rs"
mode = "compile"
hint = """
Il existe un raccourci pour initialiser les tableaux avec une certaine taille 
qui ne nécessite pas de saisir 100 éléments (mais vous pouvez certainement le faire si vous le souhaitez !).
Par exemple, vous pouvez faire :
let array = ["Are we there yet ?"; 10] ;

Bonus : quelles sont les autres choses que vous pourriez faire et qui 
retourneraient `true` pour `a.len() >= 100` ?"""

[[exercises]]
name = "primitive_types4"
path = "exercises/primitive_types/primitive_types4.rs"
mode = "test"
hint = """
Consultez la section "Understanding Ownership -> Slices -> Other Slices" du livre :
https://doc.rust-lang.org/book/ch04-03-slices.html
et utilisez les indices de début et de fin des éléments du tableau
que vous voulez retrouver dans le "slice".

Si vous êtes curieux·ses de savoir pourquoi le premier argument de `assert_eq!`
n'a pas d'esperluette pour une référence alors que le second argument est une 
référence, jetez un coup d'oeil au chapitre sur la coercion du nomicon :
https://doc.rust-lang.org/nomicon/coercions.html"""

[[exercises]]
name = "primitive_types5"
path = "exercises/primitive_types/primitive_types5.rs"
mode = "compile"
hint = """
Consultez la section "Data Types -> The Tuple Type" du livre :
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
En particulier la partie sur la déstructuration (avant-dernier exemple de la section).
Vous devrez créer un motif pour lier `name` et `age` aux parties appropriées du tuple.
Vous pouvez le faire !"""

[[exercises]]
name = "primitive_types6"
path = "exercises/primitive_types/primitive_types6.rs"
mode = "test"
hint = """
Bien que vous puissiez utiliser une déstructuration `let` pour le tuple, 
essayez plutôt de l'indexer, comme expliqué dans le dernier exemple
de la section "Data Types -> The Tuple Type" du livre :
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
Vous avez maintenant un nouvel outil dans votre boîte à outils !"""

# VECS

[[exercises]]
name = "vecs1"
path = "exercises/vecs/vecs1.rs"
mode = "test"
hint = """
En Rust, il y a deux façons de définir un vecteur.
1. La première consiste à utiliser la fonction `Vec::new()` pour créer un nouveau 
  vecteur et le remplir avec la méthode `push()`.
2. La seconde façon, plus simple, est d'utiliser la macro `vec ![]` et de
  et de définir vos éléments à l'intérieur des crochets.
Consultez ce chapitre : https://doc.rust-lang.org/stable/book/ch08-01-vectors.html
du livre Rust pour en savoir plus.
"""

[[exercises]]
name = "vecs2"
path = "exercises/vecs/vecs2.rs"
mode = "test"
hint = """
Indice 1: Dans le code, la variable `element` représente un élément du Vec lorsqu'on itère dessus.
Pouvez-vous essayer de la multiplier?

Indice 2 : Pour la première fonction, il existe un moyen d'accéder directement
aux nombres stockés dans le Vec, en utilisant l'opérateur de déréférencement *. 
Vous pouvez à la fois accéder et écrire sur le nombre de cette façon.

Après avoir exécuté les deux fonctions, décidez vous-même de l'approche que vous préférez.
Selon vous, quel est le modèle le plus couramment utilisé par les développeurs de Rust?
"""

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
path = "exercises/move_semantics/move_semantics1.rs"
mode = "compile"
hint = """
Vous avez donc l'erreur "cannot borrow immutable local variable `vec1` as mutable" à la ligne 13,
n'est-ce pas ? La solution va être d'ajouter un mot-clé, et l'ajout ne se fait PAS à la ligne 13
où se trouve l'erreur.

De plus, essayez d'accéder à `vec0` après avoir appelé `fill_vec()`. Voyez ce qui se passe !"""

[[exercises]]
name = "move_semantics2"
path = "exercises/move_semantics/move_semantics2.rs"
mode = "compile"
hint = """
Lorsque vous exécutez cet exercice pour la première fois, vous remarquerez 
une erreur "borrow of moved value". En Rust, lorsqu'un argument est passé 
à une fonction et qu'il n'est pas explicitement retourné, vous ne pouvez plus
utiliser la variable d'origine.
Nous appelons cela "déplacer" (move) une variable. Lorsque nous passons 
`vec0` dans `fill_vec`, il est "déplacé" dans `vec1`, ce qui signifie 
que nous ne pouvons plus accéder à `vec0` après.
Rust propose plusieurs façons d'atténuer ce problème, n'hésitez pas à les 
essayer toutes:
1. Vous pouvez créer une autre version des données contenues dans `vec0` 
   et la passer à `fill_vec`.
2. Faire en sorte que `fill_vec` emprunte son argument au lieu d'en prendre 
   possession, et ensuite copier les données dans la fonction (`vec.clone()`)
   afin de retourner un `Vec<i32>`.
3. Ou bien, vous pourriez faire en sorte que `fill_vec` emprunte de façon 
   *mutable* une référence à son argument (qui devra être mutable), 
   le modifier, et ne rien retourner. Cela signifie que `vec0` changera 
   au cours de la fonction, et rend `vec1` redondant (assurez-vous de 
   changer les paramètres de l'instruction `println!` si vous choisissez 
   cette solution).
"""

[[exercises]]
name = "move_semantics3"
path = "exercises/move_semantics/move_semantics3.rs"
mode = "compile"
hint = """
La différence entre cet exercice et les précédents est que la première ligne
de `fn fill_vec` qui contenait `let mut vec = vec;` n'est plus là. Vous pouvez,
au lieu d'ajouter cette ligne, ajouter `mut` à un endroit qui changera 
un binding existant en un binding mutable au lieu d'un binding immuatble :)"""

[[exercises]]
name = "move_semantics4"
path = "exercises/move_semantics/move_semantics4.rs"
mode = "compile"
hint = """
Arrêtez de lire quand vous sentez que vous avez suffisamment d'indications :) 
Ou essayez de faire une étape et de corriger les erreurs de compilation 
qui en résultent !
L'objectif final est donc de :
   - se débarrasser de la première ligne du `main` qui crée le nouveau vecteur
   - comme `vec0` n'existe plus, on ne peut pas le passer à `fill_vec`
   - la signature de `fill_vec` a changé, ce que notre appel devrait refléter
   - puisque nous ne créons plus de nouveau vec dans `main`, nous devons créer
     un nouveau vec dans `fill_vec`, de la même manière que nous l'avons fait 
     dans `main`"""

[[exercises]]
name = "move_semantics5"
path = "exercises/move_semantics/move_semantics5.rs"
mode = "compile"
hint = """
Raisonnez soigneusement sur l'étendue de la portée de chaque référence mutable.
Est-il utile de mettre à jour la valeur du référent (x) immédiatement après 
que la référence mutable est prise? En savoir plus sur les 
"références mutables" dans la section "References and Borrowing" du livre :
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references.
"""

[[exercises]]
name = "move_semantics6"
path = "exercises/move_semantics/move_semantics6.rs"
mode = "compile"
hint = """
Pour trouver la réponse, vous pouvez consulter la section 
"References and Borrowing" du livre :
https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html
Le premier problème est que `get_char` prend la propriété de la chaîne de 
caractères. Donc `data` est déplacé et ne peut pas être utilisé pour 
`string_uppercase`. `data` étant déplacé vers `get_char` en premier, 
cela qui signifie que `string_uppercase` ne peut pas manipuler les données.
Une fois que vous aurez corrigé cela, la signature de la fonction 
`string_uppercase` devra également être ajustée. Pouvez-vous trouver comment ?

Un autre indice : cela a à voir avec le caractère `&`."""

# STRUCTS

[[exercises]]
name = "structs1"
path = "exercises/structs/structs1.rs"
mode = "test"
hint = """
Rust possède plus d'un type de `struct`. En fait, toutes les variantes sont utilisées pour regrouper des données connexes.
Il y a les structures normales (ou classiques). Il s'agit de collections nommées de données connexes stockées dans des champs.
Les structures Tuple sont essentiellement des tuples nommés.
Enfin, les structs de type Unit. Elles n'ont pas de champs et sont utiles pour les génériques.

Dans cet exercice, vous devez compléter et implémenter une structure de chaque type.
Pour en savoir plus sur les structures, consultez le livre : https://doc.rust-lang.org/book/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
path = "exercises/structs/structs2.rs"
mode = "test"
hint = """
Il est facile de créer des instances de structures, il suffit d'attribuer des valeurs à leurs champs.
Il existe cependant des raccourcis qui peuvent être pris lors de l'instanciation des structures.
Pour en savoir plus, consultez le livre : https://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"""

[[exercises]]
name = "structs3"
path = "exercises/structs/structs3.rs"
mode = "test"
hint = """
Pour is_international: Qu'est-ce qui fait qu'un colis est international? Cela semble lié aux endroits par lesquels il passe, n'est-ce pas?

Pour get_fees: Cette méthode prend un argument supplémentaire, existe-t-il un champ dans la structure Package auquel elle se rapporte ?

Pour en savoir plus sur les implémentations de méthodes, jetez un coup d'œil au Livre : https://doc.rust-lang.org/book/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
path = "exercises/enums/enums1.rs"
mode = "compile"
hint = "Pas d'indices cette fois ;)"

[[exercises]]
name = "enums2"
path = "exercises/enums/enums2.rs"
mode = "compile"
hint = """
Vous pouvez créer des énumérations qui ont différentes variantes avec différents types
comme: sans données, les structures anonymes, une chaîne de caractères, les tuples, ...etc."""

[[exercises]]
name = "enums3"
path = "exercises/enums/enums3.rs"
mode = "test"
hint = """
Dans un premier temps, vous pouvez définir des enums pour compiler ce code sans erreur,
puis créer une expression `match` dans `process()`.
Notez que vous devez déconstruire certaines variantes de message
dans l'expression match pour obtenir la valeur de la variante."""

# STRINGS

[[exercises]]
name = "strings1"
path = "exercises/strings/strings1.rs"
mode = "compile"
hint = """
La fonction `current_favorite_color` retourne actuellement un "slice" de chaîne de caractère avec la durée de vie `'static''. 
Nous savons cela parce que les données de la chaîne de caractères vivent dans notre code lui-même - elles ne proviennent pas d'un fichier, d'une entrée utilisateur ou d'un autre programme - donc elles vivront aussi longtemps que notre programme.
Mais il s'agit toujours d'un slice de chaîne de caractères. Il y a une façon de créer une `String` en convertissant un slice de
chaîne de caractères qui est abordée dans le chapitre sur les chaînes de caractères, et une autre façon qui utilise.
le trait `From`."""

[[exercises]]
name = "strings2"
path = "exercises/strings/strings2.rs"
mode = "compile"
hint = """
Oui, il serait vraiment facile de corriger cela en changeant simplement la valeur liée à `word` pour qu'elle soit
un slice de chaîne de caractères au lieu d'une `String`, n'est-ce pas ? Il y a un moyen d'ajouter un caractère à la ligne
12, cependant, qu'est-ce qui forcera la `String` à devenir un slice de chaîne.

Note complémentaire : si vous souhaitez savoir comment fonctionne ce type de conversion de référence, vous pouvez avancer dans le livre et lire cette partie dans le chapitre sur les pointeurs intelligents : https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods."""

[[exercises]]
name = "strings3"
path = "exercises/strings/strings3.rs"
mode = "test"
hint = """
Il existe des tonnes de fonctions utiles de la bibliothèque standard pour les chaînes de caractères. Essayons d'en utiliser
quelques-unes d'entre elles : <https://doc.rust-lang.org/std/string/struct.String.html#method.trim> !

Pour la méthode compose_me : Vous pouvez soit utiliser la macro `format!`, soit convertir le slice de chaîne
de caractère en une chaîne possédée (owned), que vous pouvez ensuite étendre librement."""

[[exercises]]
name = "strings4"
path = "exercises/strings/strings4.rs"
mode = "compile"
hint = "Pas d'indices cette fois ;)"

# MODULES

[[exercises]]
name = "modules1"
path = "exercises/modules/modules1.rs"
mode = "compile"
hint = """
Tout est privé en Rust par défaut - mais il y a un mot-clé que nous pouvons utiliser
pour rendre quelque chose public ! L'erreur du compilateur devrait pointer vers la chose qui
doit être publique."""

[[exercises]]
name = "modules2"
path = "exercises/modules/modules2.rs"
mode = "compile"
hint = """
Le module delicious_snacks essaye de présenter une interface externe qui est
différente de sa structure interne (les modules `fruits` et `veggies` et les 
constantes associées). Complétez les déclarations `use` pour qu'elles 
correspondent aux utilisations dans `main` et trouvez le mot-clé manquant pour 
les deux constantes.
Pour en savoir plus, consultez le site https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#re-exporting-names-with-pub-use"""

[[exercises]]
name = "modules3"
path = "exercises/modules/modules3.rs"
mode = "compile"
hint = """
UNIX_EPOCH et SystemTime sont déclarés dans le module std::time. Ajoutez une 
déclaration d'utilisation pour ces deux éléments afin de les inclure dans le 
champ d'application. Vous pouvez utiliser des chemins imbriqués ou l'opérateur 
`glob` pour intégrer ces deux éléments en une seule ligne."""

# HASHMAPS

[[exercises]]
name = "hashmaps1"
path = "exercises/hashmaps/hashmaps1.rs"
mode = "test"
hint = """
Indice 1 : Regardez le type de retour de la fonction pour déterminer le type de la
  variable `basket`.
Indice 2 : Le nombre de fruits doit être d'au moins 5. Et vous devez mettre
  au moins trois types de fruits différents.
"""

[[exercises]]
name = "hashmaps2"
path = "exercises/hashmaps/hashmaps2.rs"
mode = "test"
hint = """
Utilisez les méthodes `entry()` et `or_insert()` de `HashMap` pour y parvenir.
Pour en savoir plus, consultez le site https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value
"""

[[exercises]]
name = "hashmaps3"
path = "exercises/hashmaps/hashmaps3.rs"
mode = "test"
hint = """
Indice 1 : Utilisez les méthodes `entry()` et `or_insert()` de `HashMap` pour insérer 
les entrées correspondant à chaque équipe dans le tableau des scores.
Pour en savoir plus, consultez le site https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value
Indice 2 : S'il existe déjà une entrée pour une clé donnée, la valeur retournée par `entry()` peut être mise à jour en fonction de la valeur existante.
Pour en savoir plus, consultez le site https://doc.rust-lang.org/book/ch08-03-hash-maps.html#updating-a-value-based-on-the-old-value
"""

# QUIZ 2

[[exercises]]
name = "quiz2"
path = "exercises/quiz2.rs"
mode = "test"
hint = "No hints this time ;)"

# OPTIONS

[[exercises]]
name = "options1"
path = "exercises/options/options1.rs"
mode = "test"
hint = """
Options can have a Some value, with an inner value, or a None value, without an inner value.
There's multiple ways to get at the inner value, you can use unwrap, or pattern match. Unwrapping
is the easiest, but how do you do it safely so that it doesn't panic in your face later?"""

[[exercises]]
name = "options2"
path = "exercises/options/options2.rs"
mode = "test"
hint = """
check out:
https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

Remember that Options can be stacked in if let and while let.
For example: Some(Some(variable)) = variable2
Also see Option::flatten
"""

[[exercises]]
name = "options3"
path = "exercises/options/options3.rs"
mode = "compile"
hint = """
The compiler says a partial move happened in the `match`
statement. How can this be avoided? The compiler shows the correction
needed. After making the correction as suggested by the compiler, do
read: https://doc.rust-lang.org/std/keyword.ref.html"""

# ERROR HANDLING

[[exercises]]
name = "errors1"
path = "exercises/error_handling/errors1.rs"
mode = "test"
hint = """
`Ok` and `Err` are one of the variants of `Result`, so what the tests are saying
is that `generate_nametag_text` should return a `Result` instead of an
`Option`.

To make this change, you'll need to:
   - update the return type in the function signature to be a Result<String, String> that
     could be the variants `Ok(String)` and `Err(String)`
   - change the body of the function to return `Ok(stuff)` where it currently
     returns `Some(stuff)`
   - change the body of the function to return `Err(error message)` where it
     currently returns `None`"""

[[exercises]]
name = "errors2"
path = "exercises/error_handling/errors2.rs"
mode = "test"
hint = """
One way to handle this is using a `match` statement on
`item_quantity.parse::<i32>()` where the cases are `Ok(something)` and
`Err(something)`. This pattern is very common in Rust, though, so there's
a `?` operator that does pretty much what you would make that match statement
do for you! Take a look at this section of the Error Handling chapter:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
and give it a try!"""

[[exercises]]
name = "errors3"
path = "exercises/error_handling/errors3.rs"
mode = "compile"
hint = """
If other functions can return a `Result`, why shouldn't `main`? It's a fairly common
convention to return something like Result<(), ErrorType> from your main function.
The unit (`()`) type is there because nothing is really needed in terms of positive
results."""

[[exercises]]
name = "errors4"
path = "exercises/error_handling/errors4.rs"
mode = "test"
hint = """
`PositiveNonzeroInteger::new` is always creating a new instance and returning an `Ok` result.
It should be doing some checking, returning an `Err` result if those checks fail, and only
returning an `Ok` result if those checks determine that everything is... okay :)"""

[[exercises]]
name = "errors5"
path = "exercises/error_handling/errors5.rs"
mode = "compile"
hint = """
There are two different possible `Result` types produced within `main()`, which are
propagated using `?` operators. How do we declare a return type from `main()` that allows both?

Under the hood, the `?` operator calls `From::from` on the error value to convert it to a boxed
trait object, a `Box<dyn error::Error>`. This boxed trait object is polymorphic, and since all
errors implement the `error::Error` trait, we can capture lots of different errors in one "Box"
object.

Check out this section of the book:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

Read more about boxing errors:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

Read more about using the `?` operator with boxed errors:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "errors6"
path = "exercises/error_handling/errors6.rs"
mode = "test"
hint = """
This exercise uses a completed version of `PositiveNonzeroInteger` from
errors4.

Below the line that TODO asks you to change, there is an example of using
the `map_err()` method on a `Result` to transform one type of error into
another. Try using something similar on the `Result` from `parse()`. You
might use the `?` operator to return early from the function, or you might
use a `match` expression, or maybe there's another way!

You can create another function inside `impl ParsePosNonzeroError` to use
with `map_err()`.

Read more about `map_err()` in the `std::result` documentation:
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
path = "exercises/generics/generics1.rs"
mode = "compile"
hint = """
Vectors in Rust make use of generics to create dynamically sized arrays of any type.
You need to tell the compiler what type we are pushing onto this vector."""

[[exercises]]
name = "generics2"
path = "exercises/generics/generics2.rs"
mode = "test"
hint = """
Currently we are wrapping only values of type 'u32'.
Maybe we could update the explicit references to this data type somehow?

If you are still stuck https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-method-definitions
"""

# TRAITS

[[exercises]]
name = "traits1"
path = "exercises/traits/traits1.rs"
mode = "test"
hint = """
A discussion about Traits in Rust can be found at:
https://doc.rust-lang.org/book/ch10-02-traits.html
"""

[[exercises]]
name = "traits2"
path = "exercises/traits/traits2.rs"
mode = "test"
hint = """
Notice how the trait takes ownership of 'self',and returns `Self`.
Try mutating the incoming string vector. Have a look at the tests to see
what the result should look like!

Vectors provide suitable methods for adding an element at the end. See
the documentation at: https://doc.rust-lang.org/std/vec/struct.Vec.html"""

[[exercises]]
name = "traits3"
path = "exercises/traits/traits3.rs"
mode = "test"
hint = """
Traits can have a default implementation for functions. Structs that implement
the trait can then use the default version of these functions if they choose not
implement the function themselves.

See the documentation at: https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations
"""

[[exercises]]
name = "traits4"
path = "exercises/traits/traits4.rs"
mode = "test"
hint = """
Instead of using concrete types as parameters you can use traits. Try replacing the
'??' with 'impl <what goes here?>'

See the documentation at: https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters
"""

[[exercises]]
name = "traits5"
path = "exercises/traits/traits5.rs"
mode = "compile"
hint = """
To ensure a parameter implements multiple traits use the '+ syntax'. Try replacing the
'??' with 'impl <> + <>'.

See the documentation at: https://doc.rust-lang.org/book/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax
"""

# QUIZ 3

[[exercises]]
name = "quiz3"
path = "exercises/quiz3.rs"
mode = "test"
hint = """
To find the best solution to this challenge you're going to need to think back to your
knowledge of traits, specifically Trait Bound Syntax -  you may also need this: `use std::fmt::Display;`."""

# LIFETIMES

[[exercises]]
name = "lifetimes1"
path = "exercises/lifetimes/lifetimes1.rs"
mode = "compile"
hint = """
Let the compiler guide you. Also take a look at the book if you need help:
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"""

[[exercises]]
name = "lifetimes2"
path = "exercises/lifetimes/lifetimes2.rs"
mode = "compile"
hint = """
Remember that the generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y.
You can take at least two paths to achieve the desired result while keeping the inner block:
1. Move the string2 declaration to make it live as long as string1 (how is result declared?)
2. Move println! into the inner block"""

[[exercises]]
name = "lifetimes3"
path = "exercises/lifetimes/lifetimes3.rs"
mode = "compile"
hint = """
If you use a lifetime annotation in a struct's fields, where else does it need to be added?"""

# TESTS

[[exercises]]
name = "tests1"
path = "exercises/tests/tests1.rs"
mode = "test"
hint = """
You don't even need to write any code to test -- you can just test values and run that, even
though you wouldn't do that in real life :) `assert!` is a macro that needs an argument.
Depending on the value of the argument, `assert!` will do nothing (in which case the test will
pass) or `assert!` will panic (in which case the test will fail). So try giving different values
to `assert!` and see which ones compile, which ones pass, and which ones fail :)"""

[[exercises]]
name = "tests2"
path = "exercises/tests/tests2.rs"
mode = "test"
hint = """
Like the previous exercise, you don't need to write any code to get this test to compile and
run. `assert_eq!` is a macro that takes two arguments and compares them. Try giving it two
values that are equal! Try giving it two arguments that are different! Try giving it two values
that are of different types! Try switching which argument comes first and which comes second!"""

[[exercises]]
name = "tests3"
path = "exercises/tests/tests3.rs"
mode = "test"
hint = """
You can call a function right where you're passing arguments to `assert!` -- so you could do
something like `assert!(having_fun())`. If you want to check that you indeed get false, you
can negate the result of what you're doing using `!`, like `assert!(!having_fun())`."""

[[exercises]]
name = "tests4"
path = "exercises/tests/tests4.rs"
mode = "test"
hint = """
We expect method `Rectangle::new()` to panic for negative values.
To handle that you need to add a special attribute to the test function.
You can refer to the docs:
https://doc.rust-lang.org/stable/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic"""


# STANDARD LIBRARY TYPES

[[exercises]]
name = "iterators1"
path = "exercises/iterators/iterators1.rs"
mode = "compile"
hint = """
Step 1:
We need to apply something to the collection `my_fav_fruits` before we start to go through
it. What could that be? Take a look at the struct definition for a vector for inspiration:
https://doc.rust-lang.org/std/vec/struct.Vec.html
Step 2 & step 3:
Very similar to the lines above and below. You've got this!
Step 4:
An iterator goes through all elements in a collection, but what if we've run out of
elements? What should we expect here? If you're stuck, take a look at
https://doc.rust-lang.org/std/iter/trait.Iterator.html for some ideas.
"""

[[exercises]]
name = "iterators2"
path = "exercises/iterators/iterators2.rs"
mode = "test"
hint = """
Step 1
The variable `first` is a `char`. It needs to be capitalized and added to the
remaining characters in `c` in order to return the correct `String`.
The remaining characters in `c` can be viewed as a string slice using the
`as_str` method.
The documentation for `char` contains many useful methods.
https://doc.rust-lang.org/std/primitive.char.html

Step 2
Create an iterator from the slice. Transform the iterated values by applying
the `capitalize_first` function. Remember to collect the iterator.

Step 3.
This is surprisingly similar to the previous solution. Collect is very powerful
and very general. Rust just needs to know the desired type."""

[[exercises]]
name = "iterators3"
path = "exercises/iterators/iterators3.rs"
mode = "test"
hint = """
The divide function needs to return the correct error when even division is not
possible.

The division_results variable needs to be collected into a collection type.

The result_with_list function needs to return a single Result where the success
case is a vector of integers and the failure case is a DivisionError.

The list_of_results function needs to return a vector of results.

See https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect for how
the `FromIterator` trait is used in `collect()`. This trait is REALLY powerful! It
can make the solution to this exercise infinitely easier."""

[[exercises]]
name = "iterators4"
path = "exercises/iterators/iterators4.rs"
mode = "test"
hint = """
In an imperative language, you might write a for loop that updates
a mutable variable. Or, you might write code utilizing recursion
and a match clause. In Rust you can take another functional
approach, computing the factorial elegantly with ranges and iterators.

Hint 2: Check out the `fold` and `rfold` methods!"""

[[exercises]]
name = "iterators5"
path = "exercises/iterators/iterators5.rs"
mode = "test"
hint = """
The documentation for the std::iter::Iterator trait contains numerous methods
that would be helpful here.

The collection variable in count_collection_iterator is a slice of HashMaps. It
needs to be converted into an iterator in order to use the iterator methods.

The fold method can be useful in the count_collection_iterator function.

For a further challenge, consult the documentation for Iterator to find
a different method that could make your code more compact than using fold."""

# SMART POINTERS

[[exercises]]
name = "box1"
path = "exercises/smart_pointers/box1.rs"
mode = "test"
hint = """
Step 1
The compiler's message should help: since we cannot store the value of the actual type
when working with recursive types, we need to store a reference (pointer) to its value.
We should, therefore, place our `List` inside a `Box`. More details in the book here:
https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Step 2
Creating an empty list should be fairly straightforward (hint: peek at the assertions).
For a non-empty list keep in mind that we want to use our Cons "list builder".
Although the current list is one of integers (i32), feel free to change the definition
and try other types!
"""

[[exercises]]
name = "rc1"
path = "exercises/smart_pointers/rc1.rs"
mode = "compile"
hint = """
This is a straightforward exercise to use the Rc<T> type. Each Planet has
ownership of the Sun, and uses Rc::clone() to increment the reference count of the Sun.
After using drop() to move the Planets out of scope individually, the reference count goes down.
In the end the sun only has one reference again, to itself. See more at:
https://doc.rust-lang.org/book/ch15-04-rc.html

* Unfortunately Pluto is no longer considered a planet :(
"""

[[exercises]]
name = "arc1"
path = "exercises/smart_pointers/arc1.rs"
mode = "compile"
hint = """
Make `shared_numbers` be an `Arc` from the numbers vector. Then, in order
to avoid creating a copy of `numbers`, you'll need to create `child_numbers`
inside the loop but still in the main thread.

`child_numbers` should be a clone of the Arc of the numbers instead of a
thread-local copy of the numbers.

This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Chapter 16 in the book:
https://doc.rust-lang.org/stable/book/ch16-00-concurrency.html
"""

[[exercises]]
name = "cow1"
path = "exercises/smart_pointers/cow1.rs"
mode = "test"
hint = """
If Cow already owns the data it doesn't need to clone it when to_mut() is called.

Check out https://doc.rust-lang.org/std/borrow/enum.Cow.html for documentation
on the `Cow` type.
"""

# THREADS

[[exercises]]
name = "threads1"
path = "exercises/threads/threads1.rs"
mode = "compile"
hint = """
`JoinHandle` is a struct that is returned from a spawned thread:
https://doc.rust-lang.org/std/thread/fn.spawn.html

A challenge with multi-threaded applications is that the main thread can
finish before the spawned threads are completed.
https://doc.rust-lang.org/book/ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles

Use the JoinHandles to wait for each thread to finish and collect their results.
https://doc.rust-lang.org/std/thread/struct.JoinHandle.html
"""

[[exercises]]
name = "threads2"
path = "exercises/threads/threads2.rs"
mode = "compile"
hint = """
`Arc` is an Atomic Reference Counted pointer that allows safe, shared access
to **immutable** data. But we want to *change* the number of `jobs_completed`
so we'll need to also use another type that will only allow one thread to
mutate the data at a time. Take a look at this section of the book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct
and keep reading if you'd like more hints :)


Do you now have an `Arc` `Mutex` `JobStatus` at the beginning of main? Like:
`let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));`
Similar to the code in the example in the book that happens after the text
that says "We can use Arc<T> to fix this.". If not, give that a try! If you
do and would like more hints, keep reading!!


Make sure neither of your threads are holding onto the lock of the mutex
while they are sleeping, since this will prevent the other thread from
being allowed to get the lock. Locks are automatically released when
they go out of scope.

If you've learned from the sample solutions, I encourage you to come
back to this exercise and try it again in a few days to reinforce
what you've learned :)"""

[[exercises]]
name = "threads3"
path = "exercises/threads/threads3.rs"
mode = "compile"
hint = """
An alternate way to handle concurrency between threads is to use
a mpsc (multiple producer, single consumer) channel to communicate.
With both a sending end and a receiving end, it's possible to
send values in one thread and receive them in another.
Multiple producers are possible by using clone() to create a duplicate
of the original sending end.
See https://doc.rust-lang.org/book/ch16-02-message-passing.html for more info.
"""

# MACROS

[[exercises]]
name = "macros1"
path = "exercises/macros/macros1.rs"
mode = "compile"
hint = """
When you call a macro, you need to add something special compared to a
regular function call. If you're stuck, take a look at what's inside
`my_macro`."""

[[exercises]]
name = "macros2"
path = "exercises/macros/macros2.rs"
mode = "compile"
hint = """
Macros don't quite play by the same rules as the rest of Rust, in terms of
what's available where.

Unlike other things in Rust, the order of "where you define a macro" versus
"where you use it" actually matters."""

[[exercises]]
name = "macros3"
path = "exercises/macros/macros3.rs"
mode = "compile"
hint = """
In order to use a macro outside of its module, you need to do something
special to the module to lift the macro out into its parent.

The same trick also works on "extern crate" statements for crates that have
exported macros, if you've seen any of those around."""

[[exercises]]
name = "macros4"
path = "exercises/macros/macros4.rs"
mode = "compile"
hint = """
You only need to add a single character to make this compile.
The way macros are written, it wants to see something between each
"macro arm", so it can separate them.

That's all the macro exercises we have in here, but it's barely even
scratching the surface of what you can do with Rust's macros. For a more
thorough introduction, you can have a read through the little book of Rust
macros: https://veykril.github.io/tlborm/"""

#  CLIPPY

[[exercises]]
name = "clippy1"
path = "exercises/clippy/clippy1.rs"
mode = "clippy"
hint = """
Rust stores the highest precision version of any long or infinite precision
mathematical constants in the Rust standard library.
https://doc.rust-lang.org/stable/std/f32/consts/index.html

We may be tempted to use our own approximations for certain mathematical constants,
but clippy recognizes those imprecise mathematical constants as a source of
potential error.
See the suggestions of the clippy warning in compile output and use the
appropriate replacement constant from std::f32::consts..."""

[[exercises]]
name = "clippy2"
path = "exercises/clippy/clippy2.rs"
mode = "clippy"
hint = """
`for` loops over Option values are more clearly expressed as an `if let`"""

[[exercises]]
name = "clippy3"
path = "exercises/clippy/clippy3.rs"
mode = "clippy"
hint = "No hints this time!"

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
path = "exercises/conversions/using_as.rs"
mode = "test"
hint = """
Use the `as` operator to cast one of the operands in the last line of the
`average` function into the expected return type."""

[[exercises]]
name = "from_into"
path = "exercises/conversions/from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `From` implementation"""

[[exercises]]
name = "from_str"
path = "exercises/conversions/from_str.rs"
mode = "test"
hint = """
The implementation of FromStr should return an Ok with a Person object,
or an Err with an error if the string is not valid.

This is almost like the `from_into` exercise, but returning errors instead
of falling back to a default value.

Look at the test cases to see which error variants to return.

Another hint: You can use the `map_err` method of `Result` with a function
or a closure to wrap the error from `parse::<usize>`.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "try_from_into"
path = "exercises/conversions/try_from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `TryFrom` implementation.
You can also use the example at https://doc.rust-lang.org/std/convert/trait.TryFrom.html

Is there an implementation of `TryFrom` in the standard library that
can both do the required integer conversion and check the range of the input?

Another hint: Look at the test cases to see which error variants to return.

Yet another hint: You can use the `map_err` or `or` methods of `Result` to
convert errors.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html

Challenge: Can you make the `TryFrom` implementations generic over many integer types?"""

[[exercises]]
name = "as_ref_mut"
path = "exercises/conversions/as_ref_mut.rs"
mode = "test"
hint = """
Add AsRef<str> or AsMut<u32> as a trait bound to the functions."""
