# INTRO

[[exercises]]
name = "intro1"
path = "exercises/intro/intro1.rs"
mode = "compile"
hint = """
Supprimez le commentaire J'AI PAS FINI dans le fichier exercises/intro/intro1.rs
pour passer à l'exercice suivant."""

[[exercises]]
name = "intro2"
path = "exercises/intro/intro2.rs"
mode = "compile"
hint = """
Ajoutez un argument après la chaîne de format."""

# VARIABLES

[[exercises]]
name = "variables1"
path = "exercises/variables/variables1.rs"
mode = "compile"
hint = """
Dans la déclaration de la première ligne de la fonction main, il manque un mot-clé
qui est nécessaire en Rust pour créer une nouvelle variable."""

[[exercises]]
name = "variables2"
path = "exercises/variables/variables2.rs"
mode = "compile"
hint = """
Le message du compilateur dit que Rust ne peut pas déduire le type de la
variable `x` avec les informations fournies ici.
Que se passe-t-il si vous annotez la première ligne de la fonction principale avec un type ?
Que se passe-t-il si vous donnez une valeur à `x` ?
Et si vous faites les deux ?
Quel doit être le type de `x` ?
Que se passe-t-il si `x` est du même type que 10 ? Et s'il est d'un type différent ?"""

[[exercises]]
name = "variables3"
path = "exercises/variables/variables3.rs"
mode = "compile"
hint = """
Oups ! Dans cet exercice, nous avons une variable que nous avons créée à la première ligne
de la fonction main, et nous essayons de l'utiliser à la ligne d'après, 
mais nous ne lui avons pas donné de de valeur.
Nous ne pouvons pas afficher quelque chose qui n'existe pas; essayez de donner une valeur à x!
C'est une erreur qui peut causer des bogues et qui est très facile à commettre dans n'importe quel langage de programmation.
-- heureusement, le compilateur Rust l'a détectée pour nous !"""

[[exercises]]
name = "variables4"
path = "exercises/variables/variables4.rs"
mode = "compile"
hint = """
En Rust, les variables sont immutables par défaut. Mais ici, nous essayons
de réassigner une valeur différente à x ! Il y a un mot-clé que nous pouvons utiliser pour rendre
une liaison de variable mutable."""

[[exercises]]
name = "variables5"
path = "exercises/variables/variables5.rs"
mode = "compile"
hint = """
Dans variables4, nous avons déjà appris à rendre une variable immutable mutable à l'aide d'un mot-clé spécial.
Malheureusement, cela ne nous aide pas beaucoup dans cet exercice
car nous voulons assigner une valeur de type différent à une variable existante. Parfois
on peut également réutiliser des noms de variables existants parce qu'on ne fait que convertir des
dans des types différents, comme dans cet exercice.
Heureusement, Rust dispose d'une solution puissante à ce problème: le " Shadowing " !
Vous pouvez en savoir plus sur le "Shadowing" dans la section "Variables et mutabilité" du livre:
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing
Essayez de résoudre cet exercice après avoir utilisé cette technique."""

[[exercises]]
name = "variables6"
path = "exercises/variables/variables6.rs"
mode = "compile"
hint = """
Nous connaissons les variables et la mutabilité, mais il existe un autre
type de variable: les constantes.
Les constantes sont toujours immutables et sont déclarées avec le mot-clé "const"
plutôt qu'avec le mot-clé "let".
Les types des constantes doivent également toujours être annotés.

Pour en savoir plus sur les constantes et les différences entre les variables et les constantes, consultez la rubrique "Constantes" dans la section "Variables et mutabilité" du livre:
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants
"""

# FUNCTIONS

[[exercises]]
name = "functions1"
path = "exercises/functions/functions1.rs"
mode = "compile"
hint = """
Cette fonction `main` appelle une fonction dont elle s'attend à ce qu'elle existe, 
mais cette fonction n'existe pas.
Elle s'attend à ce que cette fonction porte le nom `call_me`.
Elle s'attend à ce que cette fonction ne prenne aucun argument et ne retourne 
aucune valeur.
Cela ressemble beaucoup à `main`, n'est-ce pas ?"""

[[exercises]]
name = "functions2"
path = "exercises/functions/functions2.rs"
mode = "compile"
hint = """
Rust exige que toutes les parties de la signature d'une fonction aient des 
annotations de type, mais il manque l'annotation de type `num` à `call_me`."""

[[exercises]]
name = "functions3"
path = "exercises/functions/functions3.rs"
mode = "compile"
hint = """
Cette fois, la *déclaration* de la fonction est correcte, mais il y a 
quelque chose qui ne va pas à l'endroit où lors de l'appel de la fonction.
Pour rappel, vous pouvez librement jouer avec différentes solutions 
dans Rustlings! Le mode veille ne passera à l'exercice suivant que
si vous supprimez le commentaire J'AI PAS FINI."""

[[exercises]]
name = "functions4"
path = "exercises/functions/functions4.rs"
mode = "compile"
hint = """
Le message d'erreur pointe vers la fonction `sale_price` et indique qu'il attend un type 
après le `->`. C'est là que le type de retour de la fonction devrait être 
-- regardez la fonction `is_even` pour un exemple !

De plus, vous avez compris que, techniquement, `u32` serait le type le 
plus approprié pour les prix, puisqu'ils ne peuvent pas être négatifs ?
Si c'est le cas, bravo !"""

[[exercises]]
name = "functions5"
path = "exercises/functions/functions5.rs"
mode = "compile"
hint = """
Il s'agit d'une erreur très courante qui peut être corrigée en supprimant
un caractère. Elle se produit parce que Rust fait la distinction entre les 
expressions et les instructions: les expressions retournent une valeur 
basée sur leur(s) opérande(s), et les instructions retournent simplement 
un type () qui se comporte exactement comme `void` dans le langage C/C++.

Nous voulons retourner une valeur de type `i32` à partir de la fonction 
`square`, mais elle retourne un type `()`...
Ce n'est pas la même chose. Il y a deux solutions:
1. Ajouter un `return` avant `num * num;`
2. Supprimer `;`, et faire en sorte que ce soit `num * num`"""

# IF

[[exercises]]
name = "if1"
path = "exercises/if/if1.rs"
mode = "test"
hint = """
Il est possible de le faire en une seule ligne si vous le souhaitez !
Quelques exemples similaires dans d'autres langages:
- En C(++) ce serait: `a > b ? a : b`
- En Python, ce serait: `a if a > b ? a : b` :  `a if a > b else b`
Rappelez-vous qu'en Rust:
- la condition `if` n'a pas besoin d'être entourée de parenthèses
- Les `if`/`else` sont des expressions conditionnelles
- Chaque condition est suivie d'un bloc `{}`."""

[[exercises]]
name = "if2"
path = "exercises/if/if2.rs"
mode = "test"
hint = """
Pour cette première erreur du compilateur, il est important en Rust que 
chaque bloc conditionnel renvoie le même type !
Pour que les tests passent, vous aurez besoin de quelques
conditions vérifiant différentes valeurs d'entrée."""

[[exercises]]
name = "if3"
path = "exercises/if/if3.rs"
mode = "test"
hint = """
En Rust, chaque branche d'une expression `if` doit retourner le même type 
de valeur. Assurez-vous que le type est cohérent entre tous les bras."""

# QUIZ 1

[[exercises]]
name = "quiz1"
path = "exercises/quiz1.rs"
mode = "test"
hint = "Pas d'indice cette fois ;)"

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
path = "exercises/primitive_types/primitive_types1.rs"
mode = "compile"
hint = "Pas d'indice cette fois ;)"

[[exercises]]
name = "primitive_types2"
path = "exercises/primitive_types/primitive_types2.rs"
mode = "compile"
hint = "Pas d'indice cette fois ;)"

[[exercises]]
name = "primitive_types3"
path = "exercises/primitive_types/primitive_types3.rs"
mode = "compile"
hint = """
Il existe un raccourci pour initialiser les tableaux avec une certaine taille 
qui ne nécessite pas de saisir 100 éléments (mais vous pouvez certainement le faire si vous le souhaitez !).
Par exemple, vous pouvez faire:
let array = ["Are we there yet ?"; 10] ;

Bonus: quelles sont les autres choses que vous pourriez faire et qui 
retourneraient `true` pour `a.len() >= 100` ?"""

[[exercises]]
name = "primitive_types4"
path = "exercises/primitive_types/primitive_types4.rs"
mode = "test"
hint = """
Consultez la section "Understanding Ownership -> Slices -> Other Slices" du livre:
https://doc.rust-lang.org/book/ch04-03-slices.html
et utilisez les indices de début et de fin des éléments du tableau
que vous voulez retrouver dans le "slice".

Si vous êtes curieux·ses de savoir pourquoi le premier argument de `assert_eq!`
n'a pas d'esperluette pour une référence alors que le second argument est une 
référence, jetez un coup d'oeil au chapitre sur la coercion du nomicon:
https://doc.rust-lang.org/nomicon/coercions.html"""

[[exercises]]
name = "primitive_types5"
path = "exercises/primitive_types/primitive_types5.rs"
mode = "compile"
hint = """
Consultez la section "Data Types -> The Tuple Type" du livre:
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
En particulier la partie sur la déstructuration (avant-dernier exemple de la section).
Vous devrez créer un motif pour lier `name` et `age` aux parties appropriées du tuple.
Vous pouvez le faire !"""

[[exercises]]
name = "primitive_types6"
path = "exercises/primitive_types/primitive_types6.rs"
mode = "test"
hint = """
Bien que vous puissiez utiliser une déstructuration `let` pour le tuple, 
essayez plutôt de l'indexer, comme expliqué dans le dernier exemple
de la section "Data Types -> The Tuple Type" du livre:
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
Vous avez maintenant un nouvel outil dans votre boîte à outils !"""

# VECS

[[exercises]]
name = "vecs1"
path = "exercises/vecs/vecs1.rs"
mode = "test"
hint = """
En Rust, il y a deux façons de définir un vecteur.
1. La première consiste à utiliser la fonction `Vec::new()` pour créer un nouveau 
  vecteur et le remplir avec la méthode `push()`.
2. La seconde façon, plus simple, est d'utiliser la macro `vec ![]` et de
  et de définir vos éléments à l'intérieur des crochets.
Consultez ce chapitre: https://doc.rust-lang.org/stable/book/ch08-01-vectors.html
du livre Rust pour en savoir plus.
"""

[[exercises]]
name = "vecs2"
path = "exercises/vecs/vecs2.rs"
mode = "test"
hint = """
Indice 1: Dans le code, la variable `element` représente un élément du Vec lorsqu'on itère dessus.
Pouvez-vous essayer de la multiplier?

Indice 2: Pour la première fonction, il existe un moyen d'accéder directement
aux nombres stockés dans le Vec, en utilisant l'opérateur de déréférencement *. 
Vous pouvez à la fois accéder et écrire sur le nombre de cette façon.

Après avoir exécuté les deux fonctions, décidez vous-même de l'approche que vous préférez.
Selon vous, quel est le modèle le plus couramment utilisé par les développeurs de Rust?
"""

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
path = "exercises/move_semantics/move_semantics1.rs"
mode = "compile"
hint = """
Vous avez l'erreur "cannot borrow immutable local variable `vec1` as mutable" à la ligne
où vous essayez de `push` un élément dans le vecteur n'est-ce pas ? 
La solution va être d'ajouter un mot-clé, et l'ajout ne se fait PAS à la ligne
à la line où le `push` se fait (l'endroit où l'erreur se trouve).

De plus, essayez d'accéder à `vec0` après avoir appelé `fill_vec()`. Voyez ce qui se passe !"""

[[exercises]]
name = "move_semantics2"
path = "exercises/move_semantics/move_semantics2.rs"
mode = "compile"
hint = """
Lorsque vous exécutez cet exercice pour la première fois, vous remarquerez 
une erreur "borrow of moved value". En Rust, lorsqu'un argument est passé 
à une fonction et qu'il n'est pas explicitement retourné, vous ne pouvez plus
utiliser la variable d'origine.
Nous appelons cela "déplacer" (move) une variable. Lorsque nous passons 
`vec0` dans `fill_vec`, il est "déplacé" dans `vec1`, ce qui signifie 
que nous ne pouvons plus accéder à `vec0` après.
Rust propose plusieurs façons d'atténuer ce problème, n'hésitez pas à les 
essayer toutes:
1. Vous pouvez créer une autre version des données contenues dans `vec0` 
   et la passer à `fill_vec`.
2. Faire en sorte que `fill_vec` emprunte son argument au lieu d'en prendre 
   possession, et ensuite copier les données dans la fonction (`vec.clone()`)
   afin de retourner un `Vec<i32>`.
3. Ou bien, vous pourriez faire en sorte que `fill_vec` emprunte de façon 
   *mutable* une référence à son argument (qui devra être mutable), 
   le modifier, et ne rien retourner. Cela signifie que `vec0` changera 
   au cours de la fonction, et rend `vec1` redondant (assurez-vous de 
   changer les paramètres de l'instruction `println!` si vous choisissez 
   cette solution).
"""

[[exercises]]
name = "move_semantics3"
path = "exercises/move_semantics/move_semantics3.rs"
mode = "compile"
hint = """
La différence entre cet exercice et les précédents est que la première ligne
de `fn fill_vec` qui contenait `let mut vec = vec;` n'est plus là. Vous pouvez,
au lieu d'ajouter cette ligne, ajouter `mut` à un endroit qui changera 
un binding existant en un binding mutable au lieu d'un binding immuatble :)"""

[[exercises]]
name = "move_semantics4"
path = "exercises/move_semantics/move_semantics4.rs"
mode = "compile"
hint = """
Arrêtez de lire quand vous sentez que vous avez suffisamment d'indications :) 
Ou essayez de faire une étape et de corriger les erreurs de compilation 
qui en résultent !
L'objectif final est donc de:
   - se débarrasser de la première ligne du `main` qui crée le nouveau vecteur
   - comme `vec0` n'existe plus, on ne peut pas le passer à `fill_vec`
   - la signature de `fill_vec` a changé, ce que notre appel devrait refléter
   - puisque nous ne créons plus de nouveau vec dans `main`, nous devons créer
     un nouveau vec dans `fill_vec`, de la même manière que nous l'avons fait 
     dans `main`"""

[[exercises]]
name = "move_semantics5"
path = "exercises/move_semantics/move_semantics5.rs"
mode = "compile"
hint = """
Raisonnez soigneusement sur l'étendue de la portée de chaque référence mutable.
Est-il utile de mettre à jour la valeur du référent (x) immédiatement après 
que la référence mutable est prise? En savoir plus sur les 
"références mutables" dans la section "References and Borrowing" du livre:
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references.
"""

[[exercises]]
name = "move_semantics6"
path = "exercises/move_semantics/move_semantics6.rs"
mode = "compile"
hint = """
Pour trouver la réponse, vous pouvez consulter la section 
"References and Borrowing" du livre:
https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html
Le premier problème est que `get_char` prend la propriété de la chaîne de 
caractères. Donc `data` est déplacé et ne peut pas être utilisé pour 
`string_uppercase`. `data` étant déplacé vers `get_char` en premier, 
cela qui signifie que `string_uppercase` ne peut pas manipuler les données.
Une fois que vous aurez corrigé cela, la signature de la fonction 
`string_uppercase` devra également être ajustée. Pouvez-vous trouver comment ?

Un autre indice: cela a à voir avec le caractère `&`."""

# STRUCTS

[[exercises]]
name = "structs1"
path = "exercises/structs/structs1.rs"
mode = "test"
hint = """
Rust possède plus d'un type de `struct`. En fait, toutes les variantes sont utilisées pour regrouper des données connexes.
Il y a les structures normales (ou classiques). Il s'agit de collections nommées de données connexes stockées dans des champs.
Les structures Tuple sont essentiellement des tuples nommés.
Enfin, les structs de type Unit. Elles n'ont pas de champs et sont utiles pour les génériques.

Dans cet exercice, vous devez compléter et implémenter une structure de chaque type.
Pour en savoir plus sur les structures, consultez le livre: https://doc.rust-lang.org/book/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
path = "exercises/structs/structs2.rs"
mode = "test"
hint = """
Il est facile de créer des instances de structures, il suffit d'attribuer des valeurs à leurs champs.
Il existe cependant des raccourcis qui peuvent être pris lors de l'instanciation des structures.
Pour en savoir plus, consultez le livre: https://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"""

[[exercises]]
name = "structs3"
path = "exercises/structs/structs3.rs"
mode = "test"
hint = """
Pour is_international: Qu'est-ce qui fait qu'un colis est international? Cela semble lié aux endroits par lesquels il passe, n'est-ce pas?

Pour get_fees: Cette méthode prend un argument supplémentaire, existe-t-il un champ dans la structure Package auquel elle se rapporte ?

Pour en savoir plus sur les implémentations de méthodes, jetez un coup d'œil au Livre: https://doc.rust-lang.org/book/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
path = "exercises/enums/enums1.rs"
mode = "compile"
hint = "Pas d'indices cette fois ;)"

[[exercises]]
name = "enums2"
path = "exercises/enums/enums2.rs"
mode = "compile"
hint = """
Vous pouvez créer des énumérations qui ont différentes variantes avec différents types
comme: sans données, les structures anonymes, une chaîne de caractères, les tuples, ...etc."""

[[exercises]]
name = "enums3"
path = "exercises/enums/enums3.rs"
mode = "test"
hint = """
Dans un premier temps, vous pouvez définir des enums pour compiler ce code sans erreur,
puis créer une expression `match` dans `process()`.
Notez que vous devez déconstruire certaines variantes de message
dans l'expression match pour obtenir la valeur de la variante."""

# STRINGS

[[exercises]]
name = "strings1"
path = "exercises/strings/strings1.rs"
mode = "compile"
hint = """
La fonction `current_favorite_color` retourne actuellement un "slice" de chaîne de caractère avec la durée de vie `'static''. 
Nous savons cela parce que les données de la chaîne de caractères vivent dans notre code lui-même - elles ne proviennent pas d'un fichier, d'une entrée utilisateur ou d'un autre programme - donc elles vivront aussi longtemps que notre programme.
Mais il s'agit toujours d'un slice de chaîne de caractères. Il y a une façon de créer une `String` en convertissant un slice de
chaîne de caractères qui est abordée dans le chapitre sur les chaînes de caractères, et une autre façon qui utilise.
le trait `From`."""

[[exercises]]
name = "strings2"
path = "exercises/strings/strings2.rs"
mode = "compile"
hint = """
Oui, il serait vraiment facile de corriger cela en changeant simplement la valeur liée à `word` pour qu'elle soit
un slice de chaîne de caractères au lieu d'une `String`, n'est-ce pas ? Il y a un moyen d'ajouter un caractère à la ligne
où on appelle la fonction `is_a_color_word`, cependant, qu'est-ce qui forcera la `String` à devenir un slice de chaîne
de caractères?

Note complémentaire: si vous souhaitez savoir comment fonctionne ce type de conversion de référence, vous pouvez avancer dans le livre et lire cette partie dans le chapitre sur les pointeurs intelligents: https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods."""

[[exercises]]
name = "strings3"
path = "exercises/strings/strings3.rs"
mode = "test"
hint = """
Il existe des tonnes de fonctions utiles de la bibliothèque standard pour les chaînes de caractères. Essayons d'en utiliser
quelques-unes d'entre elles: <https://doc.rust-lang.org/std/string/struct.String.html#method.trim> !

Pour la méthode compose_me: Vous pouvez soit utiliser la macro `format!`, soit convertir le slice de chaîne
de caractère en une chaîne possédée (owned), que vous pouvez ensuite étendre librement."""

[[exercises]]
name = "strings4"
path = "exercises/strings/strings4.rs"
mode = "compile"
hint = "Pas d'indices cette fois ;)"

# MODULES

[[exercises]]
name = "modules1"
path = "exercises/modules/modules1.rs"
mode = "compile"
hint = """
Tout est privé en Rust par défaut - mais il y a un mot-clé que nous pouvons utiliser
pour rendre quelque chose public ! L'erreur du compilateur devrait pointer vers la chose qui
doit être publique."""

[[exercises]]
name = "modules2"
path = "exercises/modules/modules2.rs"
mode = "compile"
hint = """
Le module delicious_snacks essaye de présenter une interface externe qui est
différente de sa structure interne (les modules `fruits` et `veggies` et les 
constantes associées). Complétez les déclarations `use` pour qu'elles 
correspondent aux utilisations dans `main` et trouvez le mot-clé manquant pour 
les deux constantes.
Pour en savoir plus, consultez le site https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#re-exporting-names-with-pub-use"""

[[exercises]]
name = "modules3"
path = "exercises/modules/modules3.rs"
mode = "compile"
hint = """
UNIX_EPOCH et SystemTime sont déclarés dans le module std::time. Ajoutez une 
déclaration d'utilisation pour ces deux éléments afin de les inclure dans le 
champ d'application. Vous pouvez utiliser des chemins imbriqués ou l'opérateur 
`glob` pour intégrer ces deux éléments en une seule ligne."""

# HASHMAPS

[[exercises]]
name = "hashmaps1"
path = "exercises/hashmaps/hashmaps1.rs"
mode = "test"
hint = """
Indice 1: Regardez le type de retour de la fonction pour déterminer le type de la
  variable `basket`.
Indice 2: Le nombre de fruits doit être d'au moins 5. Et vous devez mettre
  au moins trois types de fruits différents.
"""

[[exercises]]
name = "hashmaps2"
path = "exercises/hashmaps/hashmaps2.rs"
mode = "test"
hint = """
Utilisez les méthodes `entry()` et `or_insert()` de `HashMap` pour y parvenir.
Pour en savoir plus, consultez le site https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value
"""

[[exercises]]
name = "hashmaps3"
path = "exercises/hashmaps/hashmaps3.rs"
mode = "test"
hint = """
Indice 1: Utilisez les méthodes `entry()` et `or_insert()` de `HashMap` pour insérer 
les entrées correspondant à chaque équipe dans le tableau des scores.
Pour en savoir plus, consultez le site https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value
Indice 2: S'il existe déjà une entrée pour une clé donnée, la valeur retournée par `entry()` peut être mise à jour en fonction de la valeur existante.
Pour en savoir plus, consultez le site https://doc.rust-lang.org/book/ch08-03-hash-maps.html#updating-a-value-based-on-the-old-value
"""

# QUIZ 2

[[exercises]]
name = "quiz2"
path = "exercises/quiz2.rs"
mode = "test"
hint = "Pas d'indices cette fois ;)"

# OPTIONS

[[exercises]]
name = "options1"
path = "exercises/options/options1.rs"
mode = "test"
hint = """
Les options peuvent avoir une valeur "Some", avec une valeur interne, ou une valeur "None", sans valeur interne.
Il y a plusieurs façons d'obtenir la valeur interne, vous pouvez utiliser unwrap, ou le pattern matching. Unwrap
est le plus simple, mais comment le faire en toute sécurité pour ne pas avoir de "panic" plus tard ?"""

[[exercises]]
name = "options2"
path = "exercises/options/options2.rs"
mode = "test"
hint = """
jetez un œil à:
https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

N'oubliez pas que les options peuvent être empilées dans les if let et while let.
Par exemple: Some(Some(variable)) = variable2
Voir aussi Option::flatten
"""

[[exercises]]
name = "options3"
path = "exercises/options/options3.rs"
mode = "compile"
hint = """
Le compilateur indique qu'un move partiel s'est produit
dans l'instruction `match`. Comment éviter cela ? Le compilateur montre la correction
nécessaire. Après avoir effectué la correction suggérée par le compilateur,
lisez: https://doc.rust-lang.org/std/keyword.ref.html"""

# ERROR HANDLING

[[exercises]]
name = "errors1"
path = "exercises/error_handling/errors1.rs"
mode = "test"
hint = """
`Ok` et `Err` sont des variantes de `Result`, donc les tests disent
que `generate_nametag_text` devrait retourner un `Result` au lieu d'une
`Option`.

Pour faire ce changement, vous devez:
   - mettre à jour le type de retour dans la signature de la fonction 
     pour qu'il soit un Resultat<String, String> qui
     qui pourrait être les variantes `Ok(String)` et `Err(String)`
   - modifier le corps de la fonction pour qu'elle retourne `Ok(stuff)` 
     alors qu'elle retourne actuellement `Some(stuff)`
   - changer le corps de la fonction pour qu'elle retourne 
    `Err(message d'erreur)` là où elle retourne renvoie actuellement `None`"""

[[exercises]]
name = "errors2"
path = "exercises/error_handling/errors2.rs"
mode = "test"
hint = """
Une façon de gérer cela est d'utiliser une expression `match` sur
`item_quantity.parse::<i32>()` où les variantes sont `Ok(something)` et
`Err(something)`. Ce schéma est très courant en Rust, donc il existe
un opérateur `?` qui fait à peu près ce que vous voudriez que l'expression match
pour vous ! Jetez un coup d'œil à cette section du chapitre sur la gestion des erreurs:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
et essayez-le !"""

[[exercises]]
name = "errors3"
path = "exercises/error_handling/errors3.rs"
mode = "compile"
hint = """
Si d'autres fonctions peuvent retourner un `Result`, pourquoi `main` ne le pourrait-il pas ? 
C'est une convention assez commune de retourner un Result<(), ErrorType> à partir de votre fonction main.
L'unité (`()`) est là parce que rien n'est vraiment nécessaire en termes de résultats
positifs."""

[[exercises]]
name = "errors4"
path = "exercises/error_handling/errors4.rs"
mode = "test"
hint = """
`PositiveNonzeroInteger::new` crée toujours une nouvelle instance et retourne un résultat `Ok`.
Il devrait faire des vérifications, retourner un résultat `Err` si ces vérifications échouent, 
et seulement retourner un `Ok` si ces vérifications déterminent que tout est... ok :)"""

[[exercises]]
name = "errors5"
path = "exercises/error_handling/errors5.rs"
mode = "compile"
hint = """
Il y a deux types de `Result` possibles produits par `main()`, qui sont propagés
propagés à l'aide de l'opérateur `?`. Comment déclarer un type de retour de `main()` qui autorise les deux ?


L'opérateur `?` appelle en fait le trait `From::from` sur la valeur de l'erreur pour la convertir
en un "boxed trait object", un `Box<dyn error::Error>`. Cet trait object est polymorphe, et puisque toutes les
erreurs implémentent le trait `error::Error`, nous pouvons capturer beaucoup d'erreurs différentes
dans un seul objet "Box".

Consultez cette section du livre:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

En savoir plus sur les erreurs et sur sa mise en ... Box:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

En savoir plus sur l'utilisation de l'opérateur `?` avec des "boxed errors":
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "errors6"
path = "exercises/error_handling/errors6.rs"
mode = "test"
hint = """
Cet exercice utilise une version complétée de `PositiveNonzeroInteger` provenant de
errors4.

Sous la ligne que TODO vous demande de changer, il y a un exemple d'utilisation de
la méthode `map_err()` sur un `Result` pour transformer un type d'erreur en
un autre. Essayez d'utiliser quelque chose de similaire sur le `Result` de `parse()`.
Vous pouvez utiliser l'opérateur `?` pour retourner de la fonction au début, 
ou vous pouvez utiliser une expression `match`, ou peut-être qu'il y a un autre moyen !

Vous pouvez créer une autre fonction dans `impl ParsePosNonzeroError` pour l'utiliser
avec `map_err()`.

Pour en savoir plus sur `map_err()`, lisez la documentation de `std::result`:
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
path = "exercises/generics/generics1.rs"
mode = "compile"
hint = """
Vectors in Rust make use of generics to create dynamically sized arrays of any type.
You need to tell the compiler what type we are pushing onto this vector."""

[[exercises]]
name = "generics2"
path = "exercises/generics/generics2.rs"
mode = "test"
hint = """
Currently we are wrapping only values of type 'u32'.
Maybe we could update the explicit references to this data type somehow?

If you are still stuck https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-method-definitions
"""

# TRAITS

[[exercises]]
name = "traits1"
path = "exercises/traits/traits1.rs"
mode = "test"
hint = """
Une discussion sur les Traits en Rust peut être trouvée à l'adresse:
https://doc.rust-lang.org/book/ch10-02-traits.html
"""

[[exercises]]
name = "traits2"
path = "exercises/traits/traits2.rs"
mode = "test"
hint = """
Remarquez que le trait prend possession de 'self' et renvoie `Self`.
Essayez de modifier le vecteur de chaîne de caractères en argument. 
Jetez un coup d'œil aux tests pour voir
ce à quoi le résultat devrait ressembler !

Les vecteurs fournissent des méthodes appropriées pour ajouter un élément à la fin. Voir
la documentation à l'adresse: https://doc.rust-lang.org/std/vec/struct.Vec.html"""

[[exercises]]
name = "traits3"
path = "exercises/traits/traits3.rs"
mode = "test"
hint = """
Les traits peuvent avoir une implémentation par défaut pour les fonctions. Les structures qui implémentent
le trait peuvent alors utiliser la version par défaut de ces fonctions si elles choisissent de ne pas
implémenter elles-mêmes la fonction.

Voir la documentation à l'adresse suivante: https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations
"""

[[exercises]]
name = "traits4"
path = "exercises/traits/traits4.rs"
mode = "test"
hint = """
Au lieu d'utiliser des types concrets comme arguments, vous pouvez utiliser des traits. 
Essayez de remplacer les ??? par "impl <que'est-ce qui va ici?>

Voir la documentation à l'adresse: https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters
"""

[[exercises]]
name = "traits5"
path = "exercises/traits/traits5.rs"
mode = "compile"
hint = """
Pour s'assurer qu'un paramètre implémente plusieurs traits, utilisez la "syntaxe +". Essayez de remplacer le `??`
par "impl <> + <>".

Voir la documentation à l'adresse: https://doc.rust-lang.org/book/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax
"""

# QUIZ 3

[[exercises]]
name = "quiz3"
path = "exercises/quiz3.rs"
mode = "test"
hint = """
Pour trouver la meilleure solution à ce défi, vous allez devoir vous référer à vos
connaissance des traits, en particulier de la syntaxe liée aux 
traits - vous pouvez aussi avoir besoin de ceci: `use std::fmt::Display;`."""

# LIFETIMES

[[exercises]]
name = "lifetimes1"
path = "exercises/lifetimes/lifetimes1.rs"
mode = "compile"
hint = """
Laissez-vous guider par le compilateur. Jetez également un coup d'œil au livre si vous avez besoin d'aide:
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"""

[[exercises]]
name = "lifetimes2"
path = "exercises/lifetimes/lifetimes2.rs"
mode = "compile"
hint = """
Rappelez-vous que la durée de vie générique 'a obtiendra la durée de vie concrète 
qui est égale à la plus petite des durées de vie de x et de y.
Vous pouvez emprunter au moins deux chemins pour obtenir le résultat souhaité tout en conservant le bloc intérieur:
1. Déplacer la déclaration de string2 pour qu'elle ait la même durée de vie que string1 (comment result est-il déclaré ?)
2. Déplacer println! dans le bloc interne"""

[[exercises]]
name = "lifetimes3"
path = "exercises/lifetimes/lifetimes3.rs"
mode = "compile"
hint = """
Si vous utilisez une annotation de durée de vie dans les champs d'une structure, où doit-elle être ajoutée ?"""

# TESTS

[[exercises]]
name = "tests1"
path = "exercises/tests/tests1.rs"
mode = "test"
hint = """
Vous n'avez même pas besoin d'écrire du code pour faire des tests 
- vous pouvez simplement tester des valeurs exécuter et exécuter le code,
même si vous ne le feriez prrobablement pas dans la vraie vie :) 
`assert!` est une macro qui a besoin d'un argument.
En fonction de la valeur de l'argument, `assert!` ne fera rien (dans ce cas, 
le test passera) ou `assert!` paniquera (auquel cas le test échouera). 
Essayez donc de donner différentes valeurs
à `assert!` et voyez lesquelles compilent, lesquelles passent, et lesquelles échouent :)"""

[[exercises]]
name = "tests2"
path = "exercises/tests/tests2.rs"
mode = "test"
hint = """
Comme pour l'exercice précédent, vous n'avez pas besoin d'écrire de code pour compiler et exécuter ce test. 
`assert_eq!` est une macro qui prend deux arguments et les compare. Essayez de lui donner deux valeurs
qui sont égales ! Essayez de lui donner deux arguments différents ! Essayez de lui donner deux valeurs
qui sont de types différents ! Essayez d'intervertir l'argument qui vient en premier et celui qui vient en second !"""

[[exercises]]
name = "tests3"
path = "exercises/tests/tests3.rs"
mode = "test"
hint = """
Vous pouvez appeler une fonction à l'endroit même où vous passez des arguments à `assert!` 
-- vous pouvez donc faire quelque chose comme `assert!(having_fun())`. 
Si vous voulez vérifier que vous obtenez bien `false`, vous pouvez 
prendre la négative du résultat de ce que vous avez fait en utilisant `!`, 
comme dans `assert!(!having_fun())`."""

[[exercises]]
name = "tests4"
path = "exercises/tests/tests4.rs"
mode = "test"
hint = """
Nous nous attendons à ce que la méthode `Rectangle::new()` panique pour les valeurs négatives.
Pour gérer cela, vous devez ajouter un attribut spécial à la fonction de test.
Vous pouvez vous référer à la documentation:
https://doc.rust-lang.org/stable/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic"""

# STANDARD LIBRARY TYPES

[[exercises]]
name = "iterators1"
path = "exercises/iterators/iterators1.rs"
mode = "compile"
hint = """
Etape 1:
Nous devons appliquer quelque chose à la collection `my_fav_fruits` avant de commencer à
la parcourir. Qu'est-ce que cela pourrait être? 
Jetez un coup d'œil à la définition de la structure d'un vecteur pour vous en inspirer:
https://doc.rust-lang.org/std/vec/struct.Vec.html
Étape 2 et 3:
Très similaires aux lignes ci-dessus et ci-dessous. Vous pouvez le faire!
Étape 4: Un itérateur parcourt tous les éléments d'une collection, 
mais que se passe-t-il si nous n'avons plus d'éléments? 
À quoi devons-nous nous attendre ici? Si vous êtes bloqué, jetez un coup d'œil à
https://doc.rust-lang.org/std/iter/trait.Iterator.html pour avoir quelques idées.
"""

[[exercises]]
name = "iterators2"
path = "exercises/iterators/iterators2.rs"
mode = "test"
hint = """
Étape 1
La variable `first` est un `char`. Elle doit être mise en majuscule et ajoutée aux
caractères restants dans `c` afin de retourner la `String` correcte.
Les caractères restants dans `c` peuvent être vus comme un slice de chaîne de caractères 
en utilisant la méthode `as_str`.
La documentation de `char` contient de nombreuses méthodes utiles.
https://doc.rust-lang.org/std/primitive.char.html

Étape 2
Créez un itérateur à partir du "slice". Transformez les valeurs itérées en appliquant
la fonction `capitalize_first`. N'oubliez pas de "collect()" l'itérateur.

Etape 3.
Cette étape est étonnamment similaire à la solution précédente. Collect est très puissant
et très général. Rust a juste besoin de connaître le type désiré."""

[[exercises]]
name = "iterators3"
path = "exercises/iterators/iterators3.rs"
mode = "test"
hint = """
La fonction "divide" doit retourner l'erreur correcte lorsque la division n'est pas possible
possible.

La variable division_results doit être collectée dans un type de collection.

La fonction result_with_list doit retourner un seul Result où le cas réussit est un vecteur 
d'entiers et le cas échoué est une DivisionError.

La fonction list_of_results doit retourner un vecteur de résultats.

Voir https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect pour savoir comment
le trait `FromIterator` est utilisé dans `collect()`. Ce trait est VRAIMENT puissant! 
Il peut rendre la solution de cet exercice infiniment plus facile."""

[[exercises]]
name = "iterators4"
path = "exercises/iterators/iterators4.rs"
mode = "test"
hint = """
Dans un langage impératif, vous pourriez écrire une boucle "for" qui met à jour
une variable mutable. Vous pouvez également écrire un code utilisant la récursivité
et une clause match. En Rust, vous pouvez adopter une autre approche
fonctionnelle, en calculant la factorielle de manière élégante avec des range et des itérateurs.

Indice 2 : Regardez les méthodes `fold` et `rfold` !"""

[[exercises]]
name = "iterators5"
path = "exercises/iterators/iterators5.rs"
mode = "test"
hint = """
La documentation du trait std::iter::Iterator contient de nombreuses méthodes
qui pourraient être utiles ici.

La variable collection dans count_collection_iterator est un slice de HashMaps. Elle
doit être convertie en itérateur afin de pouvoir utiliser les méthodes de l'itérateur.

La méthode fold peut être utile dans la fonction count_collection_iterator.

Pour relever un autre défi, consultez la documentation relative à Iterator 
pour trouver une méthode différente qui pourrait rendre votre code plus compact 
qu'avec l'utilisation de fold."""

# SMART POINTERS

[[exercises]]
name = "box1"
path = "exercises/smart_pointers/box1.rs"
mode = "test"
hint = """
Étape 1
Le message du compilateur devrait vous aider: puisque nous ne pouvons pas stocker la valeur du type
lorsqu'on travaille avec des types récursifs, nous devons stocker une référence (pointeur) à sa valeur.
Nous devons donc placer notre `List` à l'intérieur d'un `Box`. Plus de détails dans le livre ici :
https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Étape 2
Créer une liste vide devrait être assez simple (indice: regardez les assertions).
Pour une liste non vide, gardez à l'esprit que nous voulons utiliser notre Cons "constructeur de liste".
Bien que la liste actuelle soit une liste d'entiers (i32), n'hésitez pas à modifier la définition
et d'essayer d'autres types !
"""

[[exercises]]
name = "rc1"
path = "exercises/smart_pointers/rc1.rs"
mode = "compile"
hint = """
Il s'agit d'un exercice d'utilisation du type Rc<T>. 
Chaque Planète est propriétaire du Soleil et utilise Rc::clone() pour augmenter le nombre de références du Soleil.
Après avoir utilisé drop() pour sortir les planètes de la portée individuellement, le nombre de références diminue.
Au final, le soleil n'a plus qu'une seule référence, à lui-même. Pour en savoir plus, consultez le site suivant
https://doc.rust-lang.org/book/ch15-04-rc.html

* Malheureusement, Pluton n'est plus considéré comme une planète :(
"""

[[exercises]]
name = "arc1"
path = "exercises/smart_pointers/arc1.rs"
mode = "compile"
hint = """
Faites en sorte que `shared_numbers` soit un `Arc` du vecteur de nombres. 
Ensuite, pour éviter de créer une copie de `numbers`, vous devrez créer `child_numbers`
à l'intérieur de la boucle, mais toujours dans le thread principal.

`child_numbers` devrait être un clone de l'Arc des nombres au lieu d'une
copie locale des nombres dans le thread.

C'est un exercice simple si vous comprenez les concepts sous-jacents
si c'est trop difficile, envisagez de lire tout le chapitre 16 du livre :
https://doc.rust-lang.org/stable/book/ch16-00-concurrency.html
"""

[[exercises]]
name = "cow1"
path = "exercises/smart_pointers/cow1.rs"
mode = "test"
hint = """
Si Cow possède les données, il n'a pas besoin de les cloner lorsque to_mut() est appelé.

Consultez https://doc.rust-lang.org/std/borrow/enum.Cow.html pour de la documentation sur le type `Cow`
sur le type `Cow`.
"""

# THREADS

[[exercises]]
name = "threads1"
path = "exercises/threads/threads1.rs"
mode = "compile"
hint = """
`JoinHandle` est une structure qui est retournée par un thread créé :
https://doc.rust-lang.org/std/thread/fn.spawn.html

L'un des défis des applications multithreadées est que le thread principal peut 
se terminer avant que les threads créés ne soient terminés
https://doc.rust-lang.org/book/ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles

Utilisez les JoinHandles pour attendre la fin de chaque thread et collecter leurs résultats.
https://doc.rust-lang.org/std/thread/struct.JoinHandle.html
"""

[[exercises]]
name = "threads2"
path = "exercises/threads/threads2.rs"
mode = "compile"
hint = """
`Arc` (Atomic Reference Counted) est un pointeur qui permet un accès sûr et partagé à des données **immutables**
à des données **immutables**. Mais nous voulons *changer* le nombre de `jobs_completed`,
nous devrons donc utiliser un autre type qui n'autorisera qu'un seul thread à la fois
à modifier les données. Jetez un coup d'œil à cette section du livre :
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct
et continuez à lire si vous voulez plus de conseils :)

Avez-vous maintenant un `Arc` `Mutex` `JobStatus` au début de main? Comme par exemple :
`let status = Arc::new(Mutex::new(JobStatus { jobs_completed : 0 }));`
Comme le code de l'exemple dans le livre qui se trouve après le texte
qui dit "We can use Arc<T> to fix this.". Si ce n'est pas le cas, essayez!
Si c'est le cas et que vous voulez d'autres conseils, continuez à lire!

Assurez-vous qu'aucun de vos threads ne retient le verrou du mutex
pendant qu'ils dorment, car cela empêchera l'autre thread
d'obtenir le verrou. Les verrous sont automatiquement libérés
lorsqu'ils sortent de la portée.

Si vous avez appris des exemples de solutions, je vous encourage à revenir 
sur cet exercice et à le refaire dans quelques jours pour le renforcer
ce que vous avez appris :)"""

[[exercises]]
name = "threads3"
path = "exercises/threads/threads3.rs"
mode = "compile"
hint = """
Une autre façon de gérer la concurrence entre les threads est d'utiliser un canal mpsc 
(multiple producer, single consumer) pour communiquer.
Avec un émetteur et un receveur, il est possible d'envoyer des valeurs dans un 
thread et de les recevoir dans un autre.
Les producteurs multiples sont possibles en utilisant clone() pour créer un duplicata
de l'émetteur original.
Voir https://doc.rust-lang.org/book/ch16-02-message-passing.html pour plus d'informations.
"""

# MACROS

[[exercises]]
name = "macros1"
path = "exercises/macros/macros1.rs"
mode = "compile"
hint = """
Lorsque vous appelez une macro, vous devez ajouter quelque chose de spécial par rapport à
l'appel d'une fonction normale. Si vous êtes bloqué, regardez ce qu'il y a à l'intérieur de
`my_macro`."""

[[exercises]]
name = "macros2"
path = "exercises/macros/macros2.rs"
mode = "compile"
hint = """
Les macros ne suivent pas tout à fait les mêmes règles que le reste de Rust, en termes de
ce qui est disponible et où ça l'est.

Contrairement à d'autres choses en Rust, l'ordre "où vous définissez une macro" par rapport 
à "où vous l'utilisez" a de l'importance."""

[[exercises]]
name = "macros3"
path = "exercises/macros/macros3.rs"
mode = "compile"
hint = """
Pour pouvoir utiliser une macro en dehors de son module, 
il faut faire quelque chose de spécial au module pour faire sortir 
la macro dans son parent.

La même astuce fonctionne également avec les déclarations "extern crate" 
pour les crates qui ont des macros exportées, si vous en avez déjà vu."""

[[exercises]]
name = "macros4"
path = "exercises/macros/macros4.rs"
mode = "compile"
hint = """
Il suffit d'ajouter un seul caractère pour que cela compile.
De la manière dont les macros sont écrites, le compilateur veut 
voir quelque chose entre chaque "bras de macro", afin de pouvoir les distinguer.

C'est tout ce que nous avons à faire avec les macros, 
mais cela ne fait qu'effleurer la surface de ce que vous pouvez 
faire avec les macros de Rust. Pour une
une introduction plus complète, vous pouvez lire le petit livre des macros de Rust
macros : https://veykril.github.io/tlborm/"""

#  CLIPPY

[[exercises]]
name = "clippy1"
path = "exercises/clippy/clippy1.rs"
mode = "clippy"
hint = """
Rust stocke la version la plus précise des constantes mathématiques de précision longue ou infinie
dans sa librairie standard.
https://doc.rust-lang.org/stable/std/f32/consts/index.html

Nous pouvons être tentés d'utiliser nos propres approximations pour certaines constantes mathématiques,
mais Clippy reconnaît ces constantes mathématiques imprécises comme une source
d'erreur potentielle.
Voir les suggestions de l'avertissement de clippy dans la sortie de compilation et utiliser la
constante de remplacement appropriée de std::f32::consts..."""

[[exercises]]
name = "clippy2"
path = "exercises/clippy/clippy2.rs"
mode = "clippy"
hint = """
les boucles `for` sur les valeurs d'Option sont plus clairement exprimées avec un `if let`"""

[[exercises]]
name = "clippy3"
path = "exercises/clippy/clippy3.rs"
mode = "clippy"
hint = "Pas d'indices cette fois!"

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
path = "exercises/conversions/using_as.rs"
mode = "test"
hint = """
Utilisez l'opérateur `as` pour transformer l'un des opérandes de la dernière ligne 
de la fonction `average` dans le type de retour attendu."""

[[exercises]]
name = "from_into"
path = "exercises/conversions/from_into.rs"
mode = "test"
hint = """
Suivez les étapes fournies juste avant l'implémentation de `From`"""

[[exercises]]
name = "from_str"
path = "exercises/conversions/from_str.rs"
mode = "test"
hint = """
L'implémentation de FromStr doit retourner un Ok avec un objet Person,
ou un Err avec une erreur si la chaîne de caractères n'est pas valide.

C'est presque comme l'exercice `from_into`, mais en retournant les erreurs 
au lieu de d'une valeur par défaut.

Regardez les tests pour voir quelles variantes d'erreur retourner.

Autre astuce : vous pouvez utiliser la méthode `map_err` de `Result` avec une fonction
ou une fermeture pour wrapper l'erreur de `parse::<usize>`.

Encore une autre astuce: si vous voulez propager les erreurs en utilisant l'opérateur `?` 
dans votre solution, vous pouvez consulter le site suivant
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "try_from_into"
path = "exercises/conversions/try_from_into.rs"
mode = "test"
hint = """
Suivez les étapes fournies juste avant l'implémentation de `TryFrom`.
Vous pouvez également utiliser l'exemple à l'adresse https://doc.rust-lang.org/std/convert/trait.TryFrom.html

Existe-t-il une implémentation de `TryFrom` dans la bibliothèque standard qui
qui peut à la fois faire la conversion d'entiers requise et vérifier la plage de l'entrée?

Un autre indice: regardez les tests pour voir quelles variantes d'erreur retourner.

Encore un autre indice: vous pouvez utiliser les méthodes `map_err` ou `or` de `Result` pour
convertir les erreurs.

Encore un autre indice: si vous voulez propager les erreurs en utilisant l'opérateur `?` 
dans votre solution, vous pouvez consulter le site suivant
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html

Défi : Pouvez-vous rendre les implémentations `TryFrom` génériques pour de nombreux types d'entiers ?"""

[[exercises]]
name = "as_ref_mut"
path = "exercises/conversions/as_ref_mut.rs"
mode = "test"
hint = """
Ajouter AsRef<str> ou AsMut<u32> comme contrainte de trait aux fonctions."""
